/* 1.增加额外的html元素用于遮挡背景，然后为它添加如下样式 */
.overlay {
    /* 遮挡背景 */
    position: fixed;
    top: 0;
    right: 0;
    left: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
}
.lightbox {
    /* 需要吸引用户注意的元素 */
    position: absolute;
    z-index: 1;
}

/* 2用伪元素消除额外的HTML元素 */
body.dimmed::before {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: 1;
    background: rgba(0,0,0,0.8);
}

/* 不过问题是，这个方法的可移植性还不够好，因为 <body>元素上可 能有其他需求已经占用了 ::before 伪元素;
而且在使用这个效果时，我们 往往还需要一点 JavaScript 来给 <body>添加 dimmed 这个类。 */

/* 如果把遮罩层交给这个元素自己的 ::before 伪元素来实现，就可以弥 补这些不足了。给伪元素设置z-index: -1;
就可以让它出现在元素的背 后。尽管这解决了可移植性的问题，但无法对遮罩层的 Z 轴层次进行细粒度 的控制。
它可能会出现在这个元素之后(这是我们期望的)，但也可能会出 现在这个元素的父元素或祖先元素之后。 
这个方法还有一个问题，伪元素无法绑定独立的 JavaScript 事件处理 函数。 */

/* 3.box-shadow方案 */
/* box-shadow 的扩张参数可以把元素的投影向各个方 向延伸放大。具体做法就是生成一个巨大的投影，不偏移也不模糊，简单而 拙劣地模拟出遮罩层的效果:  */
.target {
box-shadow: 0 0 0 999px rgba(0, 0, 0, .8);
}

/* 满足我们需求的最小值就是 50vmax。由于投影是同时向四个方向扩展的，这个遮罩层的最终尺寸将是 100vmax 加上元素本身的尺寸。  */
.target {
box-shadow: 0 0 0 50vmax rgba(0, 0, 0, .8);
}
/* 这个技巧非常简洁易用，但它存在两个非常严重的问题，从而制约了其 使用场景。 */
/* 第一，由于遮罩层的尺寸是与视口相关，而不是与页面相关的，当我们 滚动页面时，遮罩层的边缘就露出来了，除非给它加上position: fixed;
这个样式，或者页面并没有长到需要滚动的程度。 */

/* 第二，当使用一个独立的元素(或伪元素)来实现遮罩层时，这个遮罩 层不仅可以从视觉上把用户的注意力引导到关键元素上，
还可以防止用户的 鼠标与页面的其他部分发生交互，因为遮罩层会捕获所有指针事件。box- shadow 并没有这种能力，
因此它只能在视觉上起到引导注意力的作用，却 无法阻止鼠标交互。 */








